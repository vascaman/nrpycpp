{
  "parser": {
    "namespace": "NrPyCpp",
    "header_file_to_parse": "pyrunner.h",
    "internal_object_class": "PyRunner",
    "enum_types": [],
    "int_types": [],
    "special_types": ["PyFunctionCallResult"]
  },
  "exporter": {
    "cpp_qt": {
      "generated_wrapper": "PyRunnerQt",
      "internal_pointer_var": "m_pPyRunner",
      "header_class_start": [
        "\n#ifndef PYRUNNER_QT_INCS",
        "#define PYRUNNER_QT_INCS",
        "\n#include \"PyCall.h\"",
        "#include <QStringList>",
        "#include <QVariantList>",
        "#include <QObject>",
        "\n//using namespace NrPyCpp;",
        "\nclass PyRunner;",
        "\n#ifdef WIN32",
        " #ifdef NRPYQT_LIB_EXPORTS",
        "   #define NRPYQT_LIB_API __declspec(dllexport)",
        " #else",
        "   #define NRPYQT_LIB_API __declspec(dllimport)",
        " #endif",
        "#else",
        " #define NRPYQT_LIB_API",
        "#endif",
        "\nclass NRPYQT_LIB_API PyRunnerQt: public QObject",
        "{",
        "    Q_OBJECT",
        "\n    /* Private Members*/",
        "    PyRunner *m_pPyRunner;",
        "\npublic:",
        "    PyRunnerQt(QString pythonscript, QStringList dependencies);",
        "    ~PyRunnerQt();",
        "    QString getRunnerId();",
        "    static void setSkipFinalize(bool skipFinalize);",
        "    static bool getSkipFinalize();\n\n"
      ],
      "header_class_stop": [
        "\n};",
        "\n#endif\n"
      ],
      "impl_class_start": [
        "\n#include \"pyrunner.h\"",
        "#include \"PyRunnerQt.h\"",
        "#include \"pyenvironment.h\"",
        "\n/*!",
        "    \\class PyRunnerQt",
        "    \\brief This class allows to run a python script from Qt class",
            "*/",
        "PyRunnerQt::PyRunnerQt(QString pythonscript, QStringList dependencies)",
        "{",
        "    PyEnvironment::getInstance().start();",
        "    m_pPyRunner = new PyRunner(pythonscript, dependencies);",
        "    connect(m_pPyRunner, SIGNAL(messageReceived(QString)), this, SIGNAL(messageReceived(QString)), Qt::DirectConnection);",
        "    connect(m_pPyRunner, SIGNAL(callCompletedSignal(QString)), this, SIGNAL(callCompletedSignal(QString)));",
        "\n}\n",
        "PyRunnerQt::~PyRunnerQt()",
        "{",
        "    delete m_pPyRunner;",
        "    PyEnvironment::getInstance().stop(); //FIXME we should add runner usages",
        "}\n\n",
        "/*!",
        "* \\brief PyRunner::getRunnerId, returns the runner id in order to pass this id to the python side to perform a callback.",
        "*/",
       "QString PyRunnerQt::getRunnerId()",
       "{",
       "    return m_pPyRunner->runnerId();",
       "}\n\n",
        "/*!",
        "* \\brief PyRunner::setSkipFinalize, default value is false, Py_Finalize is kinda bugged, this flag prevents any Py_Finalize call when the runner terminates.",
        "* \\param skipFinalize the new value for the option",
        "* \\note Acts at Python environment level and works for every runner terminating after setting the flag, be carefull",
        "*/",
       "void PyRunnerQt::setSkipFinalize(bool skipFinalize)",
       "{",
       "    PyEnvironment::getInstance().setSkipFinalize(skipFinalize);",
       "}\n\n",
       "/*!",
       " * \\brief PyRunner::getSkipFinalize see method PyRunner::setSkipFinalize for more",
       " * \\return the current value for skipFinalize, default value is false",
       " */",
       "bool PyRunnerQt::getSkipFinalize()",
       "{",
       "    return PyEnvironment::getInstance().getSkipFinalize();",
       "}\n\n"
      ],
      "impl_class_stop": []
    },
    "cpp_noqt": {
      "generated_wrapper": "nrPyCpp"
    }
  }
}
